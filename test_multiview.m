% Script to test the reconstruct3DMultiview function
% and plot the point cloud generated by it

% dataDir = "test/old_computer";
% dataDir = "test/delivery_area_dslr_undistorted";

imageDir = 'C:\Users\mariu\Documents\UNI_MariusGhica\Master\Semester 2\Computer Vision\tum_3D_reconstruction\delivery_area\images\dslr_images_undistorted';

if exist('images','var') == 0  % Load the images if they are not already loaded yet
    images = util.loadImages(imageDir, log=true, numImages=34);
end

% Load the camera parameters
cameraParams = logic.reconstruct3D.loadCameraParams('C:\Users\mariu\Documents\UNI_MariusGhica\Master\Semester 2\Computer Vision\tum_3D_reconstruction\delivery_area\dslr_calibration_undistorted\cameras.txt');

% Reconstruct3d multiview
fprintf('\n Reconstructing 3D...\n')
[pointCloudInstance, camPoses, tracks] = logic.reconstruct3DMultiview(images, cameraParams);

% Dense reconstruction
% fprintf('\n Dense reconstruction...\n')
% pointCloudDense = logic.reconstruct3D.denseMatchingDisparity(pointCloudInstance, images, camPoses, cameraParams, numImages=2);
% pointCloudDense = logic.reconstruct3D.denseMatchingFeature(pointCloudInstance, images, camPoses, vSet, cameraParams);
pointCloudDense = pointCloudInstance;

% Denoise the point cloud to plot it afterwards
% denoisedPointCloud = pcdenoise(pointCloudInstance);  % TODO: tweak this or simpply do this step in cuboid fitting, only test
% plotting.plotPointCloud(denoisedPointCloud, camPoses);

% numImages = numel(images);
% translation_z = zeros(numImages, 1);
% for i = 1:numImages
%     translation_z(i) = camPoses.AbsolutePose(i).Translation(3);
%     %camPoses.AbsolutePose(i).Translation(3) = 0;
% end
% figure;
% plotCamera(camPoses, Size=0.2);
% 
% figure;
% plot(1:numImages, translation_z);